// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.18/esri/copyright.txt for details.
//>>built
define("../../chunks/_rollupPluginBabelHelpers ../../chunks/tslib.es6 ../../core/has ../../core/maybe ../../core/Logger ../../core/accessorSupport/decorators/property ../../core/accessorSupport/decorators/cast ../../core/jsonMap ../../core/accessorSupport/decorators/subclass ../../core/Error ../../core/urlUtils ../../core/uuid ../../portal/support/resourceExtension ../../core/Collection ../../Graphic ../../core/watchUtils ../../tasks/support/AttachmentQuery ../../layers/support/AttachmentInfo ../../core/HandleOwner ../Feature/support/featureUtils".split(" "),
function(p,h,f,w,G,m,x,H,y,e,I,J,K,z,A,B,r,C,D,E){const t={editing:!1,operations:{add:!0,update:!0,delete:!0}},u=z.ofType(C);f=function(v){function n(a){var b=v.call(this,a)||this;b._getAttachmentsPromise=null;b._attachmentLayer=null;b.abilities={...t};b.activeAttachmentInfo=null;b.attachmentInfos=new u;b.graphic=null;b.mode="view";b.handles.add([B.init(p._assertThisInitialized(b),"graphic",()=>b._graphicChanged())]);return b}p._inheritsLoose(n,v);var g=n.prototype;g.destroy=function(){this.graphic=
this._attachmentLayer=null};g.castAbilities=function(a){return{...t,...a}};g.getAttachments=async function(){const {_attachmentLayer:a,attachmentInfos:b}=this;if(!a||"function"!==typeof a.queryAttachments)throw new e("invalid-layer","getAttachments(): A valid layer is required.");const d=this._getFeatureId();var c=new r({objectIds:[d],returnMetadata:!0});const k=[];this._getAttachmentsPromise=c=a.queryAttachments(c).then(l=>l[d]||k).catch(()=>k);this.notifyChange("state");c=await c;b.removeAll();
c.length&&b.addMany(c);this._getAttachmentsPromise=null;this.notifyChange("state");return c};g.addAttachment=async function(a){const {_attachmentLayer:b,attachmentInfos:d,graphic:c,abilities:k}=this;if(!a)throw new e("invalid-attachment","addAttachment(): An attachment is required.",{attachment:a});if(!k.operations.add)throw new e("invalid-abilities","addAttachment(): add abilities are required.");if(!b||"function"!==typeof b.addAttachment)throw new e("invalid-layer","addAttachment(): A valid layer is required.");
a=await b.addAttachment(c,a).then(l=>this._queryAttachment(l.objectId));d.add(a);return a};g.deleteAttachment=async function(a){const {_attachmentLayer:b,attachmentInfos:d,graphic:c,abilities:k}=this;if(!a)throw new e("invalid-attachment-info","deleteAttachment(): An attachmentInfo is required.",{attachmentInfo:a});if(!k.operations.delete)throw new e("invalid-abilities","deleteAttachment(): delete abilities are required.");if(!b||"function"!==typeof b.deleteAttachments)throw new e("invalid-layer",
"deleteAttachment(): A valid layer is required.");const l=await b.deleteAttachments(c,[a.id]).then(()=>a);d.remove(l);return l};g.updateAttachment=async function(a,b=this.activeAttachmentInfo){const {_attachmentLayer:d,attachmentInfos:c,graphic:k,abilities:l}=this;if(!a)throw new e("invalid-attachment","updateAttachment(): An attachment is required.",{attachment:a});if(!b)throw new e("invalid-attachment-info","updateAttachment(): An attachmentInfo is required.",{attachmentInfo:b});if(!l.operations.update)throw new e("invalid-abilities",
"updateAttachment(): Update abilities are required.");const F=c.findIndex(q=>q===b);if(!d||"function"!==typeof d.updateAttachment)throw new e("invalid-layer","updateAttachment(): A valid layer is required.");a=await d.updateAttachment(k,b.id,a).then(q=>this._queryAttachment(q.objectId));c.splice(F,1,a);return a};g._queryAttachment=async function(a){if(!a)throw new e("invalid-attachment-id","Could not query attachment.");const {_attachmentLayer:b}=this,d=this._getFeatureId();a=new r({objectIds:[d],
attachmentsWhere:`AttachmentId=${a}`,returnMetadata:!0});return b.queryAttachments(a).then(c=>c[d][0])};g._getFeatureId=function(){const {_attachmentLayer:a,graphic:b}=this;if(!a||!b)return null;const {objectIdField:d}=a,{attributes:c}=b;return c&&c[d]};g._graphicChanged=function(){this.graphic&&(this._setAttachmentLayer(),this.getAttachments().catch(()=>{}))};g._setAttachmentLayer=function(){var {graphic:a}=this;this._attachmentLayer=(a=E.getSourceLayer(a))?"scene"===a.type&&w.isSome(a.associatedLayer)?
a.associatedLayer:a:null};p._createClass(n,[{key:"state",get:function(){return this._getAttachmentsPromise?"loading":this.graphic?"ready":"disabled"}},{key:"supportsResizeAttachments",get:function(){return this.get("graphic.layer.capabilities.operations.supportsResizeAttachments")||!1}}]);return n}(D.HandleOwner);h.__decorate([m.property()],f.prototype,"abilities",void 0);h.__decorate([x.cast("abilities")],f.prototype,"castAbilities",null);h.__decorate([m.property()],f.prototype,"activeAttachmentInfo",
void 0);h.__decorate([m.property({readOnly:!0,type:u})],f.prototype,"attachmentInfos",void 0);h.__decorate([m.property({type:A})],f.prototype,"graphic",void 0);h.__decorate([m.property()],f.prototype,"mode",void 0);h.__decorate([m.property({dependsOn:["graphic"],readOnly:!0})],f.prototype,"state",null);h.__decorate([m.property({readOnly:!0,dependsOn:["graphic","graphic.layer","graphic.layer.loaded","graphic.layer.capabilities.operations.supportsResizeAttachments"]})],f.prototype,"supportsResizeAttachments",
null);return f=h.__decorate([y.subclass("esri.widgets.Attachments.AttachmentsViewModel")],f)});