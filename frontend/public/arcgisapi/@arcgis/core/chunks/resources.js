/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.18/esri/copyright.txt for details.
*/
import{throwIfAborted as t}from"../core/promiseUtils.js";import{c as e}from"./mathUtils2.js";import{c as i}from"./vec3f64.js";import{f as s,l as a,s as r}from"./vec3.js";import{r as l}from"./requestImageUtils.js";class n{constructor(t){this.gain=t}update(t){if(this.hasLastValue){const e=this.computeDelta(t);this.updateDelta(e)}this.lastValue=t}reset(){this.lastValue=void 0,this.filteredDelta=void 0}get hasLastValue(){return void 0!==this.lastValue}get hasFilteredDelta(){return void 0!==this.filteredDelta}computeDelta(t){return t-this.lastValue}updateDelta(t){this.hasFilteredDelta?this.filteredDelta=(1-this.gain)*this.filteredDelta+this.gain*t:this.filteredDelta=t}}class h{constructor(t,e,i){this._initialVelocity=t,this._stopVelocity=e,this._friction=i,this._duration=Math.abs(Math.log(Math.abs(this._initialVelocity)/this._stopVelocity)/Math.log(1-this._friction))}get duration(){return this._duration}isFinished(t){return t>this.duration}get friction(){return this._friction}value(t){return this.valueFromInitialVelocity(this._initialVelocity,t)}valueDelta(t,e){const i=this.value(t);return this.value(t+e)-i}valueFromInitialVelocity(t,e){e=Math.min(e,this.duration);const i=1-this.friction;return t*(Math.pow(i,e)-1)/Math.log(i)}}class o extends h{constructor(t,e,i,s,a){super(t,e,i),this.sceneVelocity=s,this.direction=a}value(t){return super.valueFromInitialVelocity(this.sceneVelocity,t)}}class u{constructor(t=300,e=12,s=.84){this.minimumInitialVelocity=t,this.stopVelocity=e,this.friction=s,this.enabled=!0,this.time=new n(.6),this.screen=[new n(.4),new n(.4)],this.scene=[new n(.6),new n(.6),new n(.6)],this.tmpDirection=i()}add(t,e,i){if(this.enabled){if(this.time.hasLastValue){if(this.time.computeDelta(i)<.015)return}this.screen[0].update(t[0]),this.screen[1].update(t[1]),this.scene[0].update(e[0]),this.scene[1].update(e[1]),this.scene[2].update(e[2]),this.time.update(i)}}reset(){this.screen[0].reset(),this.screen[1].reset(),this.scene[0].reset(),this.scene[1].reset(),this.scene[2].reset(),this.time.reset()}evaluateMomentum(){if(!this.enabled||!this.screen[0].hasFilteredDelta)return null;const t=this.screen[0].filteredDelta,e=this.screen[1].filteredDelta,i=Math.sqrt(t*t+e*e)/this.time.filteredDelta;return Math.abs(i)<this.minimumInitialVelocity?null:this.createMomentum(i,this.stopVelocity,this.friction)}createMomentum(t,e,i){s(this.tmpDirection,this.scene[0].filteredDelta,this.scene[1].filteredDelta,this.scene[2].filteredDelta);const l=a(this.tmpDirection);l>0&&r(this.tmpDirection,this.tmpDirection,1/l);const n=l/this.time.filteredDelta;return new o(t,e,i,n,this.tmpDirection)}}class c{constructor(t=2.5,e=.01,i=.95,s=12){this.minimumInitialVelocity=t,this.stopVelocity=e,this.friction=i,this.maxVelocity=s,this.enabled=!0,this.value=new n(.8),this.time=new n(.3)}add(t,e){if(this.enabled){if(this.time.hasLastValue){if(this.time.computeDelta(e)<.01)return;if(this.value.hasFilteredDelta){const e=this.value.computeDelta(t);this.value.filteredDelta*e<0&&this.value.reset()}}this.time.update(e),this.value.update(t)}}reset(){this.value.reset(),this.time.reset()}evaluateMomentum(){if(!this.enabled||!this.value.hasFilteredDelta)return null;let t=this.value.filteredDelta/this.time.filteredDelta;return t=e(t,-this.maxVelocity,this.maxVelocity),Math.abs(t)<this.minimumInitialVelocity?null:this.createMomentum(t,this.stopVelocity,this.friction)}createMomentum(t,e,i){return new h(t,e,i)}}class m extends c{constructor(t=3,e=.01,i=.95,s=12){super(t,e,i,s)}add(t,e){if(this.value.hasLastValue){const e=this.value.lastValue;let i=t-e;for(;i>Math.PI;)i-=2*Math.PI;for(;i<-Math.PI;)i+=2*Math.PI;t=e+i}super.add(t,e)}}class d extends h{constructor(t,e,i){super(t,e,i)}value(t){const e=super.value(t);return Math.exp(e)}valueDelta(t,e){const i=super.value(t),s=super.value(t+e)-i;return Math.exp(s)}}class p extends c{constructor(t=2.5,e=.01,i=.95,s=12){super(t,e,i,s)}add(t,e){super.add(Math.log(t),e)}createMomentum(t,e,i){return new d(t,e,i)}}async function f(e){const i=import("./mask-svg.js"),s=import("./overlay-svg.js"),a=l((await i).default,{signal:e}),r=l((await s).default,{signal:e}),n={mask:await a,overlay:await r};return t(e),n}export{n as F,h as M,u as P,m as R,p as Z,f as l};
